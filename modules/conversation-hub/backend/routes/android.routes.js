import crypto from 'crypto';

async function getBcrypt() {
  try {
    const b = await import('bcrypt');
    return b.default || b;
  } catch {
    const b = await import('bcryptjs');
    return b.default || b;
  }
}

function jsonError(res, status, error, message) {
  try {
    return res.status(status).json({ ok: false, error, ...(message ? { message } : {}) });
  } catch {
    return res.status(status).end();
  }
}

function requireAdmin(ctx, req, res) {
  try {
    if (ctx && typeof ctx.requireAdmin === 'function') return ctx.requireAdmin(req, res);
  } catch {}
  jsonError(res, 401, 'unauthorized');
  return null;
}

function requireAuth(ctx, req, res) {
  try {
    if (ctx && typeof ctx.requireAuth === 'function') return ctx.requireAuth(req, res);
  } catch {}
  jsonError(res, 401, 'unauthorized');
  return null;
}

function orgKeyFrom(req, user) {
  const headers = (req && req.headers) ? req.headers : {};
  const fromHeader = (headers['x-org-id'] || headers['x-orgid'] || null);
  if (fromHeader != null && String(fromHeader).trim()) return String(fromHeader).trim();
  const fromUser = (user && (user.org_id || user.orgId)) ? (user.org_id || user.orgId) : null;
  if (fromUser != null && String(fromUser).trim()) return String(fromUser).trim();
  return 'default';
}

async function ensureAndroidClientsTable(pool) {
  if (!pool) return;
  await pool.query(`
    CREATE TABLE IF NOT EXISTS public.mod_conversation_hub_android_clients (
      id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      org_id TEXT NOT NULL DEFAULT 'default',
      agent_email TEXT NULL,
      device_id TEXT NOT NULL,
      app_version TEXT NULL,
      last_seen TIMESTAMP DEFAULT NOW(),
      created_at TIMESTAMP DEFAULT NOW(),
      updated_at TIMESTAMP DEFAULT NOW()
    );
  `);
  await pool.query(`
    CREATE UNIQUE INDEX IF NOT EXISTS uq_mod_conversation_hub_android_clients_org_device
    ON public.mod_conversation_hub_android_clients(org_id, device_id);
  `);
  await pool.query(`
    CREATE INDEX IF NOT EXISTS idx_mod_conversation_hub_android_clients_last_seen
    ON public.mod_conversation_hub_android_clients(last_seen);
  `);
}

async function ensureAndroidUsersTable(pool) {
  if (!pool) return;
  await pool.query(`
    CREATE TABLE IF NOT EXISTS public.mod_conversation_hub_android_users (
      id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      org_id TEXT NOT NULL DEFAULT 'default',
      email TEXT NOT NULL,
      label TEXT NULL,
      enabled SMALLINT NOT NULL DEFAULT 1,
      created_at TIMESTAMP DEFAULT NOW(),
      updated_at TIMESTAMP DEFAULT NOW()
    );
  `);
  await pool.query(`
    CREATE UNIQUE INDEX IF NOT EXISTS uq_mod_conversation_hub_android_users_org_email
    ON public.mod_conversation_hub_android_users(org_id, email);
  `);
  await pool.query(`
    CREATE INDEX IF NOT EXISTS idx_mod_conversation_hub_android_users_org
    ON public.mod_conversation_hub_android_users(org_id);
  `);
}

async function getAgentsTable(pool) {
  try {
    const r = await pool.query("SELECT to_regclass('public.mod_agents_agents') AS t1, to_regclass('public.agents') AS t2");
    const row = (r && r.rows && r.rows[0]) || {};
    if (row.t1) return 'public.mod_agents_agents';
    if (row.t2) return 'public.agents';
  } catch {}
  return 'public.mod_agents_agents';
}

async function upsertAndroidAgent({ pool, orgId, email, password }) {
  const table = await getAgentsTable(pool);
  const b = await getBcrypt();
  const hash = await b.hash(String(password), 10);

  const existing = await pool.query(`SELECT id, email FROM ${table} WHERE lower(email) = lower($1) LIMIT 1`, [email]);
  if (existing.rowCount) {
    const id = (existing.rows && existing.rows[0] && existing.rows[0].id) ? existing.rows[0].id : null;
    await pool.query(
      `UPDATE ${table}
          SET password = $1,
              updated_at = NOW(),
              org_id = COALESCE(org_id, $2)
        WHERE lower(email) = lower($3)`,
      [hash, orgId || null, email]
    );
    return { id, created: false };
  }

  const name = 'Android Agent';
  const role = 'agent';
  const preferredLang = 'fr';
  const notifications = '{}';
  const themeColor = '#2563eb';
  const themeColor2 = '#0d9488';

  const ins = await pool.query(
    `INSERT INTO ${table} (org_id, name, email, password, role, is_active, preferred_lang, notifications, theme_color, theme_color2, created_at, updated_at)
     VALUES ($1,$2,$3,$4,$5,1,$6,$7::jsonb,$8,$9,NOW(),NOW())
     RETURNING id`,
    [orgId || null, name, email, hash, role, preferredLang, notifications, themeColor, themeColor2]
  );
  return { id: (ins.rows && ins.rows[0] && ins.rows[0].id) ? ins.rows[0].id : null, created: true };
}

function randomPassword() {
  // Node-compatible base64url without relying on Buffer.toString('base64url')
  const raw = crypto.randomBytes(12).toString('base64');
  return raw.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '').slice(0, 18);
}

function normalizeEmail(email) {
  return String(email || '').trim().toLowerCase();
}

function toBool(v, def) {
  if (v === true || v === false) return v;
  if (v == null) return !!def;
  const s = String(v).trim().toLowerCase();
  if (!s) return !!def;
  if (s === '1' || s === 'true' || s === 'yes' || s === 'on') return true;
  if (s === '0' || s === 'false' || s === 'no' || s === 'off') return false;
  return !!def;
}

async function migrateLegacySettingToDb({ pool, orgId, getSetting, setSetting }) {
  try {
    const key = `conversation_hub_android_agent_email__${orgId}`;
    const legacy = normalizeEmail(await getSetting(key));
    if (!legacy) return;
    await ensureAndroidUsersTable(pool);
    await pool.query(
      `INSERT INTO public.mod_conversation_hub_android_users (org_id, email, label, enabled, created_at, updated_at)
       VALUES ($1,$2,$3,1,NOW(),NOW())
       ON CONFLICT (org_id, email) DO NOTHING`,
      [orgId, legacy, 'Legacy Android user']
    );
    // Keep legacy setting for backward-compat, but DB becomes the source of truth.
    try { await setSetting(key, legacy); } catch {}
  } catch {}
}

async function listAndroidUsersWithStatus({ pool, orgId }) {
  await ensureAndroidUsersTable(pool);
  await ensureAndroidClientsTable(pool);

  const usersRes = await pool.query(
    `SELECT id, email, label, enabled, created_at, updated_at
       FROM public.mod_conversation_hub_android_users
      WHERE org_id = $1
      ORDER BY id ASC`,
    [orgId]
  );
  const users = (usersRes.rows || []).map((u) => ({
    id: u.id,
    email: normalizeEmail(u.email),
    label: u.label || '',
    enabled: Number(u.enabled) ? true : false,
    created_at: u.created_at || null,
    updated_at: u.updated_at || null,
  }));

  const clientsRes = await pool.query(
    `SELECT agent_email, MAX(last_seen) AS last_seen, COUNT(*)::int AS devices_count
       FROM public.mod_conversation_hub_android_clients
      WHERE org_id = $1 AND agent_email IS NOT NULL AND agent_email <> ''
      GROUP BY agent_email`,
    [orgId]
  );
  const emailToStatus = new Map();
  for (const r of (clientsRes.rows || [])) {
    const email = normalizeEmail(r.agent_email);
    const lastSeen = r.last_seen ? new Date(r.last_seen).toISOString() : null;
    const lastSeenMs = r.last_seen ? new Date(r.last_seen).getTime() : 0;
    const connected = !!(lastSeenMs && (Date.now() - lastSeenMs) < 2 * 60 * 1000);
    emailToStatus.set(email, { last_seen: lastSeen, connected, devices_count: Number(r.devices_count || 0) });
  }

  const devicesRes = await pool.query(
    `SELECT device_id, agent_email, app_version, last_seen
       FROM public.mod_conversation_hub_android_clients
      WHERE org_id = $1
      ORDER BY last_seen DESC
      LIMIT 100`,
    [orgId]
  );
  const devices = (devicesRes.rows || []).map((d) => ({
    device_id: d.device_id,
    agent_email: normalizeEmail(d.agent_email),
    app_version: d.app_version || null,
    last_seen: d.last_seen || null,
  }));

  const items = users.map((u) => {
    const st = emailToStatus.get(u.email) || { connected: false, last_seen: null, devices_count: 0 };
    return { ...u, connected: !!st.connected, last_seen: st.last_seen || null, devices_count: st.devices_count || 0 };
  });

  return { items, devices };
}

async function getAndroidUserByEmail({ pool, orgId, email }) {
  await ensureAndroidUsersTable(pool);
  const em = normalizeEmail(email);
  if (!em) return null;
  const r = await pool.query(
    `SELECT id, email, label, enabled, created_at, updated_at
       FROM public.mod_conversation_hub_android_users
      WHERE org_id = $1 AND lower(email) = lower($2)
      LIMIT 1`,
    [orgId, em]
  );
  return (r.rows && r.rows[0]) ? r.rows[0] : null;
}

export function registerConversationHubAndroidRoutes(app, ctx = {}) {
  const pool = ctx.pool;
  const getSetting = typeof ctx.getSetting === 'function' ? ctx.getSetting : (async () => null);
  const setSetting = typeof ctx.setSetting === 'function' ? ctx.setSetting : (async () => {});

  // Admin: list Android users (DB-backed) + connection status from heartbeats
  app.get('/api/conversation-hub/android-users', async (req, res) => {
    const admin = requireAdmin(ctx, req, res);
    if (!admin || !pool) return;
    try {
      const orgId = orgKeyFrom(req, admin);
      await migrateLegacySettingToDb({ pool, orgId, getSetting, setSetting });
      const out = await listAndroidUsersWithStatus({ pool, orgId });
      return res.json({ ok: true, org_id: orgId, items: out.items, devices: out.devices });
    } catch (e) {
      return jsonError(res, 500, 'server_error', (e && e.message) ? e.message : 'server_error');
    }
  });

  // Admin: upsert Android user (create/update), optionally reset agent password
  app.post('/api/conversation-hub/android-users', async (req, res) => {
    const admin = requireAdmin(ctx, req, res);
    if (!admin || !pool) return;
    try {
      const orgId = orgKeyFrom(req, admin);
      await ensureAndroidUsersTable(pool);
      const body = req.body || {};

      const id = body.id != null && String(body.id).trim() ? Number(body.id) : null;
      const email = normalizeEmail(body.email);
      if (!email) return jsonError(res, 400, 'bad_request', 'email required');
      const label = body.label != null ? String(body.label).trim().slice(0, 200) : '';
      const enabled = toBool(body.enabled, true);

      // Ensure row exists (by id or by email)
      let row = null;
      if (id && Number.isFinite(id)) {
        const r = await pool.query(
          `UPDATE public.mod_conversation_hub_android_users
              SET email = $1, label = $2, enabled = $3, updated_at = NOW()
            WHERE org_id = $4 AND id = $5
            RETURNING id, email, label, enabled, created_at, updated_at`,
          [email, label || null, enabled ? 1 : 0, orgId, id]
        );
        row = (r.rows && r.rows[0]) ? r.rows[0] : null;
      } else {
        const r = await pool.query(
          `INSERT INTO public.mod_conversation_hub_android_users (org_id, email, label, enabled, created_at, updated_at)
           VALUES ($1,$2,$3,$4,NOW(),NOW())
           ON CONFLICT (org_id, email)
           DO UPDATE SET label = EXCLUDED.label, enabled = EXCLUDED.enabled, updated_at = NOW()
           RETURNING id, email, label, enabled, created_at, updated_at`,
          [orgId, email, label || null, enabled ? 1 : 0]
        );
        row = (r.rows && r.rows[0]) ? r.rows[0] : null;
      }
      if (!row) return jsonError(res, 404, 'not_found', 'user not found');

      const doGenerate = !!body.generate;
      const passwordRaw = String(body.password || '').trim();
      const shouldSetPassword = doGenerate || !!passwordRaw;
      let generatedPassword = null;
      let agent = null;
      if (shouldSetPassword) {
        const pwd = doGenerate ? randomPassword() : passwordRaw;
        if (!pwd) return jsonError(res, 400, 'bad_request', 'password required');
        const up = await upsertAndroidAgent({ pool, orgId, email, password: pwd });
        agent = up;
        if (doGenerate) generatedPassword = pwd;
      }

      const out = {
        id: row.id,
        email: normalizeEmail(row.email),
        label: row.label || '',
        enabled: Number(row.enabled) ? true : false,
        created_at: row.created_at || null,
        updated_at: row.updated_at || null,
      };

      return res.json({ ok: true, org_id: orgId, item: out, ...(agent ? { agent } : {}), ...(generatedPassword ? { generated_password: generatedPassword } : {}) });
    } catch (e) {
      return jsonError(res, 500, 'server_error', (e && e.message) ? e.message : 'server_error');
    }
  });

  // Admin: delete Android user (DB-backed)
  app.delete('/api/conversation-hub/android-users/:id', async (req, res) => {
    const admin = requireAdmin(ctx, req, res);
    if (!admin || !pool) return;
    try {
      const orgId = orgKeyFrom(req, admin);
      await ensureAndroidUsersTable(pool);
      const id = Number(req.params.id);
      if (!Number.isFinite(id)) return jsonError(res, 400, 'bad_request', 'invalid id');
      await pool.query(`DELETE FROM public.mod_conversation_hub_android_users WHERE org_id=$1 AND id=$2`, [orgId, id]);
      return res.json({ ok: true });
    } catch (e) {
      return jsonError(res, 500, 'server_error', (e && e.message) ? e.message : 'server_error');
    }
  });

  // Admin: disconnect an Android user (clears known devices/heartbeats for that agent_email)
  app.post('/api/conversation-hub/android-users/:id/disconnect', async (req, res) => {
    const admin = requireAdmin(ctx, req, res);
    if (!admin || !pool) return;
    try {
      const orgId = orgKeyFrom(req, admin);
      await ensureAndroidClientsTable(pool);
      await ensureAndroidUsersTable(pool);
      const id = Number(req.params.id);
      if (!Number.isFinite(id)) return jsonError(res, 400, 'bad_request', 'invalid id');
      const ur = await pool.query(
        `SELECT email FROM public.mod_conversation_hub_android_users WHERE org_id=$1 AND id=$2 LIMIT 1`,
        [orgId, id]
      );
      const email = ur.rows && ur.rows[0] ? normalizeEmail(ur.rows[0].email) : '';
      if (!email) return jsonError(res, 404, 'not_found', 'user not found');
      const dr = await pool.query(
        `DELETE FROM public.mod_conversation_hub_android_clients WHERE org_id=$1 AND lower(agent_email)=lower($2)`,
        [orgId, email]
      );
      return res.json({ ok: true, org_id: orgId, email, deleted: { clients: Number(dr && dr.rowCount ? dr.rowCount : 0) } });
    } catch (e) {
      return jsonError(res, 500, 'server_error', (e && e.message) ? e.message : 'server_error');
    }
  });

  // Admin: read configured Android agent + live status
  app.get('/api/conversation-hub/android-user', async (req, res) => {
    const admin = requireAdmin(ctx, req, res);
    if (!admin || !pool) return;
    try {
      const orgId = orgKeyFrom(req, admin);
      await migrateLegacySettingToDb({ pool, orgId, getSetting, setSetting });
      const out = await listAndroidUsersWithStatus({ pool, orgId });
      const first = (out.items || []).find((x) => x && x.enabled) || (out.items || [])[0] || null;
      return res.json({
        ok: true,
        org_id: orgId,
        email: first ? first.email : '',
        connected: first ? !!first.connected : false,
        devices: out.devices || [],
        users: out.items || [],
      });
    } catch (e) {
      return jsonError(res, 500, 'server_error', (e && e.message) ? e.message : 'server_error');
    }
  });

  // Admin: set Android agent email and (optionally) set/reset password for that agent
  app.post('/api/conversation-hub/android-user', async (req, res) => {
    const admin = requireAdmin(ctx, req, res);
    if (!admin || !pool) return;
    try {
      const orgId = orgKeyFrom(req, admin);
      await ensureAndroidUsersTable(pool);
      await ensureAndroidClientsTable(pool);
      const key = `conversation_hub_android_agent_email__${orgId}`; // legacy compat

      const body = req.body || {};
      const emailRaw = normalizeEmail(body.email);
      if (!emailRaw) return jsonError(res, 400, 'bad_request', 'email required');

      const doGenerate = !!body.generate;
      const passwordRaw = String(body.password || '').trim();
      const shouldSetPassword = doGenerate || !!passwordRaw;

      // Upsert into DB list (single call keeps legacy endpoint working)
      await pool.query(
        `INSERT INTO public.mod_conversation_hub_android_users (org_id, email, label, enabled, created_at, updated_at)
         VALUES ($1,$2,$3,1,NOW(),NOW())
         ON CONFLICT (org_id, email)
         DO UPDATE SET enabled=1, updated_at=NOW()`,
        [orgId, emailRaw, 'Android user']
      );

      let generatedPassword = null;
      if (shouldSetPassword) {
        const pwd = doGenerate ? randomPassword() : passwordRaw;
        if (!pwd) return jsonError(res, 400, 'bad_request', 'password required');
        const { id, created } = await upsertAndroidAgent({ pool, orgId, email: emailRaw, password: pwd });
        if (doGenerate) generatedPassword = pwd;
        try { await setSetting(key, emailRaw); } catch {}
        return res.json({ ok: true, org_id: orgId, email: emailRaw, agent: { id, created }, ...(generatedPassword ? { generated_password: generatedPassword } : {}) });
      }

      try { await setSetting(key, emailRaw); } catch {}
      return res.json({ ok: true, org_id: orgId, email: emailRaw, agent: null });
    } catch (e) {
      return jsonError(res, 500, 'server_error', (e && e.message) ? e.message : 'server_error');
    }
  });

  // Android client heartbeat (requires auth cookie) so the web UI can show "connected" status.
  app.post('/api/conversation-hub/android/heartbeat', async (req, res) => {
    const user = requireAuth(ctx, req, res);
    if (!user || !pool) return;
    try {
      await ensureAndroidClientsTable(pool);
      const orgId = orgKeyFrom(req, user);
      const body = req.body || {};
      const deviceId = String(body.device_id || body.deviceId || '').trim();
      if (!deviceId) return jsonError(res, 400, 'bad_request', 'device_id required');
      const appVersion = body.app_version != null ? String(body.app_version) : (body.appVersion != null ? String(body.appVersion) : null);
      const agentEmail = (user && user.email) ? String(user.email) : null;
      const agentEmailNorm = normalizeEmail(agentEmail);

      // If an android user record exists for this email, require it to be enabled.
      // If no record exists, allow heartbeat (backward compat), but it won't show up in the users list.
      try {
        const u = await getAndroidUserByEmail({ pool, orgId, email: agentEmailNorm });
        if (u && Number(u.enabled) === 0) return jsonError(res, 403, 'android_user_disabled', 'Android user is disabled.');
      } catch {}

      await pool.query(
        `INSERT INTO public.mod_conversation_hub_android_clients (org_id, agent_email, device_id, app_version, last_seen, created_at, updated_at)
         VALUES ($1,$2,$3,$4,NOW(),NOW(),NOW())
         ON CONFLICT (org_id, device_id)
         DO UPDATE SET agent_email=EXCLUDED.agent_email, app_version=EXCLUDED.app_version, last_seen=NOW(), updated_at=NOW()`,
        [orgId, agentEmailNorm || agentEmail, deviceId, appVersion]
      );

      return res.json({ ok: true, org_id: orgId, device_id: deviceId, at: Date.now() });
    } catch (e) {
      return jsonError(res, 500, 'server_error', (e && e.message) ? e.message : 'server_error');
    }
  });
}
