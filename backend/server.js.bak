import "dotenv/config";
import express from "express";
import http from "http";
import { Server } from "socket.io";
import cors from "cors";
import path from "path";
import { fileURLToPath } from "url";
import fs from "fs";
import pgPkg from "pg";

import { createLogger } from "./src/core/logger.js";
import { textToSafeHTML, sanitizeAgentHtmlServer } from "./src/shared/safeHtml.js";
import { createAuthModule } from "./src/modules/auth/index.js";
import { loadModuleHooks, loadModuleRoutes } from "./src/modules/loader.js";
/* [DECOUPLED-MODULES-BEGIN]
   Legacy sidebar (filesystem-scanned) is disabled in favor of
   Module Manager's DB-backed sidebar endpoints.
   import { registerSidebarRoutes } from "./src/modules/sidebar.routes.js";
   [DECOUPLED-MODULES-END] */

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Logger
const logger = createLogger({
  logFile: path.join(__dirname, "chat.log"),
  defaultEnabled: !/^(0|false|no)$/i.test(process.env.LOG_ENABLED || "1"),
  defaultStdout: /^(1|true|yes)$/i.test(process.env.LOG_STDOUT || ""),
});
const logToFile = (message) => logger.logToFile(message);
const getLogFilePath = () => logger.getLogFile();
const isLogEnabled = () => logger.isEnabled();
const isLogStdout = () => logger.isStdout();
const setLogStdout = (value) => logger.setStdout(value);

// Global error handlers
try {
  process.on("uncaughtException", (e) => {
    try { logToFile(`[uncaughtException] ${e?.stack || e}`); } catch {}
  });
  process.on("unhandledRejection", (e) => {
    try { logToFile(`[unhandledRejection] ${e?.stack || e}`); } catch {}
  });
} catch {}

// Optional PostgreSQL connection (used by modules)
let pgPool = null;
async function getPg() {
  if (pgPool) return pgPool;
  try {
    const { Pool } = pgPkg;
    // Load backend-local .env if DATABASE_URL not provided
    try {
      if (!process.env.DATABASE_URL && !process.env.PGHOST) {
        const localEnv = path.join(__dirname, ".env");
        if (fs.existsSync(localEnv)) {
          const dotenv = await import("dotenv");
          try { dotenv.config({ path: localEnv }); } catch {}
        }
      }
    } catch {}

    const url = String(process.env.DATABASE_URL || "").trim();
    const enabled = !!url || !!process.env.PGHOST || !!process.env.PGDATABASE;
    if (!enabled) return null;
    const common = { connectionTimeoutMillis: 3000, idleTimeoutMillis: 30000 };
    if (url) pgPool = new Pool({ connectionString: url, ...common });
    else pgPool = new Pool({
      host: process.env.PGHOST || "127.0.0.1",
      port: Number(process.env.PGPORT || 5432),
      user: process.env.PGUSER || "postgres",
      password: process.env.PGPASSWORD || "",
      database: process.env.PGDATABASE || "postgres",
      ...common,
    });
    await pgPool.query("select 1");
    return pgPool;
  } catch (e) {
    try { logToFile(`[pg] connect_failed ${e?.message || e}`); } catch {}
    return null;
  }
}

// Minimal settings store (DB-backed when Postgres available)
async function ensureSettingsTable() {
  try {
    const p = await getPg();
    if (!p) return;
    await p.query(
      `CREATE TABLE IF NOT EXISTS settings (
         key TEXT PRIMARY KEY,
         value TEXT,
         updated_at TIMESTAMP DEFAULT NOW()
       )`
    );
  } catch {}
}
async function getSetting(key) {
  try {
    const k = String(key || "").trim();
    if (!k) return null;
    const envKey = k.toUpperCase();
    if (process.env[envKey]) return String(process.env[envKey]);
    const p = await getPg();
    if (!p) return null;
    await ensureSettingsTable();
    const r = await p.query(`SELECT value FROM settings WHERE key=$1 LIMIT 1`, [k]);
    return r.rowCount ? (r.rows[0].value || null) : null;
  } catch { return null; }
}
async function setSetting(key, value) {
  try {
    const k = String(key || "").trim();
    const v = value == null ? "" : String(value);
    const envKey = k.toUpperCase();
    if (["OPENAI_API_KEY", "MCP_TOKEN", "MCP_DEV_TOKEN", "DATABASE_URL"].includes(envKey)) {
      try { process.env[envKey] = v; } catch {}
    }
    const p = await getPg();
    if (!p) return;
    await ensureSettingsTable();
    await p.query(
      `INSERT INTO settings(key, value, updated_at)
       VALUES ($1,$2,NOW())
       ON CONFLICT (key) DO UPDATE SET value=EXCLUDED.value, updated_at=NOW()`,
      [k, v]
    );
  } catch {}
}
function getOpenaiApiKey() { try { return String(process.env.OPENAI_API_KEY || ""); } catch { return ""; } }
function getMcpToken() { try { return String(process.env.MCP_TOKEN || ""); } catch { return ""; } }

// Auth shim (modules may override via createAuthModule)
let __requireAdminImpl = null;
function requireAdminAuth(req, res) {
  try {
    if (typeof __requireAdminImpl === "function") return __requireAdminImpl(req, res);
    const expected = process.env.ADMIN_TOKEN || "";
    if (expected) {
      const got = req.headers["x-admin-token"] || (req.query && (req.query.admin_token || req.query.ADMIN_TOKEN));
      if (String(got) === expected) return { role: "admin" };
    }
    res.status(401).json({ error: "unauthorized" });
    return null;
  } catch {
    try { res.status(401).json({ error: "unauthorized" }); } catch {}
    return null;
  }
}
function hasAdminTokenNonDestructive(req) {
  try {
    const expected = process.env.ADMIN_TOKEN || "";
    if (expected) {
      const got = req.headers["x-admin-token"] || req.query?.admin_token;
      return String(got) === expected;
    }
    return isLocalhost(req);
  } catch { return false; }
}
function isLocalhost(req) {
  try {
    const ip = (req.ip || "").toString();
    return ip === "127.0.0.1" || ip === "::1" || ip.startsWith("::ffff:127.0.0.1");
  } catch { return false; }
}

// Express + Socket.IO
const app = express();
app.set("trust proxy", true);
const server = http.createServer(app);
const io = new Server(server, { path: "/socket", cors: { origin: "*" }, perMessageDeflate: false, allowEIO3: true });

app.use(cors());

// Allow passing admin token via query (?admin_token=...) as a fallback
app.use((req, _res, next) => {
  try {
    const q = req.query && (req.query.admin_token || req.query.ADMIN_TOKEN);
    if (q && !req.headers["x-admin-token"]) req.headers["x-admin-token"] = String(q);
  } catch {}
  next();
});

// Serve built frontend (Vite dist)
const distDir = path.resolve(process.env.FRONTEND_DIST_DIR || path.join(__dirname, "../frontend/dist"));
const indexHtml = path.join(distDir, "index.html");
const distExists = (() => { try { return fs.existsSync(indexHtml); } catch { return false; } })();
logToFile(`[static] distDir = ${distDir}`);
logToFile(`[static] index.html exists? ${distExists}`);
if (distExists) app.use(express.static(distDir));

// Body parser for API routes
app.use(["/api", "/messages"], express.json({ limit: "50mb" }));

// Health endpoints
app.get("/__health", (_req, res) => {
  res.json({ distDir, indexHtmlExists: fs.existsSync(indexHtml), cwd: process.cwd(), __dirname });
});
app.get("/health", (_req, res) => { res.json({ ok: true }); });

// SPA fallback for non-API routes so direct visits don't show "Cannot GET /"
try {
  // Exclude static assets and known API paths
  app.get(/^(?!\/(assets\/|favicon\.ico$|api\/|messages\/|socket|__health$|health$)).*/, (req, res, next) => {
    try {
      if (!fs.existsSync(indexHtml)) return next();
      try { res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate'); } catch {}
      return res.sendFile(indexHtml);
    } catch { return next(); }
  });
} catch {}

/* ====================== Settings + Module Loader ========================= */
// Lightweight DB wrapper compatible with modules
const modulePool = {
  async query(...args) {
    const p = await getPg();
    if (!p) throw new Error("db_unavailable");
    return p.query(...args);
  },
};

// Safe defaults for extras used by some modules
const dbSchema = { useDbDedup: false, visitors: { idCol: "id", hasVisitorIdCol: true }, messages: { hasContent: true, hasMessage: false, hasContentHtml: true, hasAgentId: true } };
async function ensureVisitorExists(_id) { return; }
async function upsertVisitorColumns(_id, _cols) { return; }

// Readiness flag
let serverReady = false;

// Server.js now avoids defining module-specific /api/* routes; modules own APIs.

// Boot guard for login route: only pass-through after modules loaded
app.post("/api/auth/login", (req, res, next) => {
  if (!serverReady) return res.status(503).json({ error: "starting" });
  return next();
});

// Generic helpers
function publicBaseFromReq(req) {
  try {
    const proto = (req.headers["x-forwarded-proto"] || req.protocol || "http").toString();
    const host = (req.headers["x-forwarded-host"] || req.headers["host"] || "").toString();
    if (!host) return "";
    return `${proto}://${host}`.replace(/\/$/, "");
  } catch { return ""; }
}

// Initialize Auth and dynamically load modules
try {
  const auth = createAuthModule({ app, pool: modulePool, logToFile });
  var authFromRequest = auth.authFromRequest;
  var requireAuth = auth.requireAuth;
  var requireAdmin = auth.requireAdmin;
  __requireAdminImpl = requireAdmin;
} catch (e) { try { logToFile("auth module init failed: " + (e?.message || e)); } catch {} }

try {
  await loadModuleHooks({ app, pool: modulePool, requireAdmin: requireAdminAuth, getSetting, setSetting, logToFile, extras: { getLogFilePath, isLogEnabled, isLogStdout, setLogStdout } });
} catch (e) { try { logToFile("module hooks load failed: " + (e?.message || e)); } catch {} }

try {
  await loadModuleRoutes({
    app,
    pool: modulePool,
    requireAuth,
    requireAdmin: requireAdminAuth,
    getSetting,
    setSetting,
    logToFile,
    extras: { getLogFilePath, isLogEnabled, isLogStdout, setLogStdout, io, dbSchema, ensureVisitorExists, upsertVisitorColumns, sanitizeAgentHtmlServer, textToSafeHTML, getOpenaiApiKey, getMcpToken, publicBaseFromReq },
  });
} catch (e) { try { logToFile("module routes load failed: " + (e?.message || e)); } catch {} }

/* [DECOUPLED-MODULES-BEGIN]
// Dynamic sidebar tree (legacy, filesystem-scanned)
// Disabled in favor of Module Manager's DB-backed sidebar endpoints.
// try { registerSidebarRoutes(app, {}); } catch {}
[DECOUPLED-MODULES-END] */

// Mark server ready
serverReady = true;

/* ============================ START ======================================= */
const PORT = Number(process.env.PORT || 3010);

server.on("error", (err) => {
  if (err && err.code === "EADDRINUSE") {
    logToFile(`âŒ Port ${PORT} already in use. Exiting.`);
    process.exit(1);
  } else {
    throw err;
  }
});

if (!server.listening) {
  server.listen(PORT, "0.0.0.0", () => {
    logToFile(`ðŸš€ Server listening at http://0.0.0.0:${PORT}`);
  });
}
